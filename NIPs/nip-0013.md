# NIP 13 - Security Token Standard

```
    NIP: 13
    Layer: Library
    Title: Security Token Standard
    Author: Gregory Saive <greg@nem.foundation>
    Discussions-To: https://github.com/nemtech/NIP/issues/42
    Comments-URI: https://github.com/nemtech/NIP/issues/42
    Status: Draft
    Type: Standards Track
    Created: 2019-07-29
    License: Apache-2.0
```

## Table of contents

- [Introduction](#introduction)
- [Motivation](#motivation)
- [Rationale](#rationale)
  * [Partially Fungible Tokens](#partially-fungible-tokens)
- [Specification](#specification)
  * [Requirements](#requirements)
  * [Terminology](#terminology)
  * [Features Description](#features-description)
  * [Token Commands](#token-commands)
  * [Token Restrictions](#token-restrictions)
  * [Token Metadata](#token-metadata)
  * [Failure Codes](#failure-codes)
- [Design Decisions](#design-decisions)
  * [1. Namespaced Standards](#1--namespaced-standards)
  * [2. Standard Submodules](#2--standard-submodules)
  * [3. Disposability and re-use](#3--disposability-and-re-use)
  * [4. Network agnostic](#4--network-agnostic)
  * [5. Deterministic accounts](5-deterministic-accounts)
- [Implementation](#implementation)
  * [Packaging Proposal](#packaging-proposal)
  * [Architecture Proposal](#architecture-proposal)
  * [Implementation Proposal](#implementation-proposal)
    + [Interfaces](#interfaces)
  * [Requirements Compliancy](#requirements-compliancy)
  * [Ongoing Work](#ongoing-work)
- [Backwards compatibility](#backwards-compatibility)
- [References](#references)
- [History](#history)

## Introduction

This document aims to provide with a **standard** for _issuance_ and _management_ of **security tokens** on Symbol. This standard will be structured as such that _standard interfaces_ will be defined to facilitate _operations_ and _interrogations_ related to security tokens.

## Motivation 

Facilitate and accelerate the processes of _issuance_ and _management_ of security tokens on Symbol.

To issue and manage securities on Symbol, this standard will leverage several Symbol features. Implementation details will be described in a document jointly to this standard definition.

## Rationale

Security token transfers can fail for different reasons in contrast to utility tokens. As for utility tokens it generally requires only the sender to have a sufficient balance.

> ... [The conditions for failure] could be related to metadata of the securities being transferred (i.e. whether they are subject to a lock-up period), the identity of the sender and receiver of the securities (i.e. whether they have been through a KYC process, whether they are accredited or an affiliate of the issuer) or for reasons unrelated to the specific transfer but instead set at the token level (i.e. the token contract enforces a maximum number of investors or a cap on the percentage held by any single investor).

For tokens representing securities, this standard introduces a function `canTransfer` which provides a general purpose path to achieve this when _the reasons for failure of a transfer are more complex_; _and/or a function of the whole transfer_ (i.e. includes any data sent with the transfer and the receiver of the securities).

Quoted: [ERC#1400 `Security Token Standard`][erc-1400]

### Partially Fungible Tokens

Security tokens can be used to represent many types of assets which need to have _differentiating data_ attached to them and/or signed.

This additional metadata - when added at a token level - implicitely renders these securities _non-fungible_, but in practice said data will be applied to a _subset of the security_ rather than an individual security.

With this standard, we introduce the ability to **partition** a token holder's balance intro partitions, _each with separate metadata_. 

> A token holder's balance may be split in two: those tokens issued during the primary issuance, and those received through secondary trading.

> Security token contracts can reference this metadata in order to apply additional logic to determine whether or not a transfer is valid, and determine the metadata that should be associated with the tokens once transferred into the receiver's balance.

Quoted: [ERC#1400 `Security Token Standard`][erc-1400]

## Specification

### Requirements

The security token standards to be described in this document will be based on features available with [Symbol][symbol] networks. Additionally, for each standard, we will define requirements that will apply to the underlying asset class.

> In aggregate provides a suite of standard interfaces for issuing / redeeming security tokens, managing their ownership and transfer restrictions and providing transparency to token holders on how different subsets of their token balance behave with respect to transfer restrictions, rights and obligations.In aggregate provides a suite of standard interfaces for issuing / redeeming security tokens, managing their ownership and transfer restrictions and providing transparency to token holders on how different subsets of their token balance behave with respect to transfer restrictions, rights and obligations.

- MUST have a standard interface to query feasibility of a transfer and return a reason for failures.
- MUST be able to perform forced transfer for legal action or fund recovery.
- MUST define standard notifications for issuance and redemption processes.
- MUST be able to attach metadata to a **subset of a token holder's balance**.
- MUST be able to modify metadata at time of transfer based on off-chain data, on-chain data and the parameters of the transfer.
- MUST support querying and subscribing to updates on any relevant documentation for the security.
- MAY require signed data to be passed into a transfer transaction in order to validate it on-chain.
- SHOULD NOT restrict the range of asset classes across jurisdictions which can be represented.

Source: [ERC#1400 `Security Token Standard`][erc-1400]

### Terminology

A **token** is represented by a multitude of features available with Symbol. This includes _mosaics_, _multi-signature accounts_, _namespaces_ and _metadata_.

A **token authority** is used to list tokens. One _token authority_ can list many _tokens_. There will be many token authorities (registrars) created with the sole purpose of listing tokens. In a future iteration, _token authorities_ may need to verify the creation of tokens they will be listing.

A **token command** can be executed by _operators_ for their published _tokens_. A list of available token commands can be found [here](#token-commands).

A **token operator** must have permissions to digitally _govern_ published tokens. There can be many operators for one token and the list of operators can change with the execution of some _token commands_.

A **target account** is a deterministically created account that must be converted to a _multi-signature account_ where _cosignatories_ are **token operators**.

A **target mosaic** is a mosaic that is published to the network after the execution of the token command `CreateToken`. The **target mosaic** is owned by the **target account** and therefor _governed_ by the **token operators**.

A **token partition** represents _a part of the available token balance_ and can be _owned_ by a _partition owner_. One token partition can always be _owned by one token owner_. The assignment of partitions can be tracked using a special transfer transaction signed by the _target account_.

For each **token partition**, there will be one _added multi-signature account_ of which _token operator accounts_ are a cosignatory.

A **partition owner** can be any account on Symbol networks which is not the **target account**, nor one of the listed **token operator**.

A **token source** represents the original network of issuance of said token.

### Features Description

Following features table will be used to define mandatory features of the published software package:

| Feature | Motivation | NIP13 Status |
| --- | --- | --- |
| Issuance | Issuance of security tokens is managed through `owner` | :white_check_mark: |
| Issuer Power Delegation | `Operators` can be allowed specific management tasks of the security tokens | :white_check_mark: |
| Transfer |  Security tokens can be transferred (change ownership) | :white_check_mark: |
| Batch Transfer | Security tokens can be transferred in batches (change ownership) | :white_check_mark: |
| Transfer with Metadata | Metadata can be added to transfers of security tokens | :white_check_mark: |
| Metadata management | Metadata can be managed for security tokens | :white_check_mark: |
| Transfer restrictions | Transfers of security tokens can be restricted (constraints) | :white_check_mark: |
| Freeze/Lock | Security token balances can be frozen/locked by `operators` | :white_check_mark: |
| Operator enforcement | `Operators` can be allowed tasks enforcements (such as transfers) | :white_check_mark: |
| Force Transfer | Transfers of security tokens can be **enforced**. | :white_check_mark: |
| Error signaling | Error signaling is described for each Standard | :white_check_mark: |
| Document management | Documents can be attached to security tokens [ownerships] | :white_check_mark: |

### Token Commands

Token Standards introduce the term of **commands** that are executed for specific tokens. For instance, the transfer of token happens by _executing the command TransferOwnership_ for said token.

This concept of _commands_ will be available for all Token Standards. As such we will define a list of commands that will also be technically defined in the implementation details.

| Token Command | Rationale |
| --- | --- |
| **CreateToken** | Create a security token (non-reversible) |
| **TransferOwnership** | Transfer a token to a new owner (Also used for issuance to single recipient) |
| **TransferOwnershipWithData** | Transfer a token to a new owner, adding signed data as a message |
| **BatchTransferOwnership** | Batch Transfer tokens to new owners |
| **BatchTransferOwnershipWithData** | Batch Transfer tokens to new owners, adding signed data as a message |
| **ForcedTransfer** | Force the transfer of a token to a new owner, with an operator account |
| **LockBalance** | Freeze / Lock a token balance (full or part of partition) |
| **UnlockBalance** | Unfreeze / Unlock a token balance (full or part of partition) |
| **ModifyRestriction** | Send modifications to account/mosaic restrictions |
| **ModifyMetadata** | Send modifications to account/mosaic metadata |
| **DelegateIssuerPower** | Delegate issuance authorizations to (new) operator(s) account(s) |
| **RevokeIssuerPower** | Revoke issuance authorizations of operator(s) account(s) |
| **AttachDocument** | Attach documents to a token instance |

### Token Restrictions

> **Token restrictions** MUST leverage [_Symbol mosaic restrictions features_](https://nemtech.github.io/concepts/mosaic-restriction.html).

1. A **target account** MUST be configured with following **account mosaic restrictions**:

- Add account mosaic restriction with flag `AllowMosaic` for said security token mosaic id.
- Add account mosaic restriction with flag `AllowMosaic` for the network currency mosaic id.

2. A **target mosaic** MUST be configured with following **mosaic global restriction**:

- Add mosaic global restriction of type `LE` (less or equal) with value `2` and key `User_Role`.
  * Proposed possible values includes: [1 = Target, 2 = Holder, 3 = Guest, 4 = Locked].

3. A **target mosaic** MUST be configured with following **mosaic address restrictions**:

- Add mosaic address restriction with value `1` (1 = Target) for _target account_.
- Add mosaic address restriction with value `2` (2 = Holder) for _each token partition_ - if any available.

4. A **token partition** MUST be configured with following **account mosaic restrictions**:

- Add account mosaic restriction with flag `AllowMosaic` for said security token mosaic id.
- Add account mosaic restriction with flag `AllowMosaic` for the network currency mosaic id.

### Token Metadata

> **Token metadata** MUST leverage [_Symbol metadata features_](https://nemtech.github.io/concepts/metadata.html).

1. A **target account** MUST be configured with the following **account metadata**:

- Add account metadata with key `NIP13` and value being the _token identifier_.

2. A **target mosaic** MUST be configured with the following **mosaic metadata**:

- Add mosaic metadata with key `NIP13` and value being the _token identifier_.
- Add mosaic metadata with key `NAME` and value being the _name of the financial instrument_.

3. (Optional) A **target mosaic** SHOULD be configured with the following **mosaic metadata**:

- Add mosaic metadata with key `MIC` and value being the _Market Identifier Code of the financial instrument_.
- Add mosaic metadata with key `ISIN` and value being the _International Securities Identification Number (ISIN) of the financial instrument_.
- Add mosaic metadata with key `ISO_10962` and value being the _classification of the financial instrument as described in ISO_10962_.

4. A **token partition** MUST be configured with the following **account metadata**:

- Add mosaic metadata with key `NAME` and value being the _name of the token partition_.

### Failure Codes

In an attempt to make the token holder experience better, the provided `canTransfer` function MUST return a _reason byte code_ on success or failure based on the NIP-13 application-specific status codes specified below. 

An implementation can also return arbitrary data as a `uint8_t` to provide additional information not captured by the reason code.

> Codes break nicely into a 16x16 matrix, represented as a 2-digit hex number. The high nibble represents the code’s kind or “category”, and the low nibble contains the state or “reason”. We present them below as separate tables per range for explanatory and layout reasons.

| Code | Reason | Failure |
| --- | --- | --- |
| **0x0* Generic Failure Codes** | | |
| 0x00 | Failure | `Failure_Generic` |
| 0x01 | Success | `Success_Generic` | 
| 0x02 | Awaiting Others | `Info_Awaiting_Parties` | 
| 0x03 | Accepted | `Success_Accepted` |
| 0x04 | Lower Limit or Insufficient | `Failure_Lower_Limit` |
| 0x05 | Receiver Action Requested | `Info_Receiver_Action_Requested` |
| 0x06 | Upper Limit | `Failure_Upper_Limit` |
| 0x07 | [reserved] | _Currently unspecified_ |
| 0x08 | [reserved] | _Currently unspecified_ |
| 0x09 | [reserved] | _Currently unspecified_ |
| 0x0A | [reserved] | _Currently unspecified_ |
| 0x0B | [reserved] | _Currently unspecified_ |
| 0x0C | [reserved] | _Currently unspecified_ |
| 0x0D | [reserved] | _Currently unspecified_ |
| 0x0E | [reserved] | _Currently unspecified_ |
| 0x0F | Informational or Metadata | `Info_Generic` |
| **0x1* Permission and Control** | | |
| 0x10 | Disallowed or Stop | `Failure_Disallowed` |
| 0x11 | Allowed or Go | `Success_Allowed` |
| 0x12 | Awaiting Other’s Permission | `Info_Awaiting_Parties_Permission` |
| 0x13 | Permission Requested | `Success_Permission_Requested` |
| 0x14 | Too Open / Insecure | `Failure_Insecure_Action` |
| 0x15 | Needs Your Permission or Request for Continuation | `Failure_Needs_Permission` |
| 0x16 | Revoked or Banned | `Failure_Permission_Revoked` |
| 0x17 | [reserved] | _Currently unspecified_ |
| 0x18 | Not Applicable to Current State | `Failure_Permission_Not_Applicable` |
| 0x19 | [reserved] | _Currently unspecified_ |
| 0x1A | [reserved] | _Currently unspecified_ |
| 0x1B | [reserved] | _Currently unspecified_ |
| 0x1C | [reserved] | _Currently unspecified_ |
| 0x1D | [reserved] | _Currently unspecified_ |
| 0x1E | [reserved] | _Currently unspecified_ |
| 0x1F | Permission Details or Control Conditions | `Info_Permission_Details` |
| **| 0x2* Find, Inequalities and Ranges** | | |
| 0x20 | Not Found, Unequal, or Out of Range | `Failure_Not_Found` |
| 0x21 | Found, Equal or In Range | `Success_Found` |
| 0x22 | Awaiting Match | `Info_Awaiting_Match` |
| 0x23 | Match Request Sent | `Success_Match_Request_Sent` |
| 0x24 | Below Range or Underflow | `Failure_Below_Range` |
| 0x25 | Request for Match | `Info_Request_For_Match` |
| 0x26 | Above Range or Overflow | `Failure_Above_Range` |
| 0x27 | [reserved] | _Currently unspecified_ |
| 0x28 | Duplicate, Conflict, or Collision | `Failure_Duplicate_Conflict` |
| 0x29 | [reserved] | _Currently unspecified_ |
| 0x2A | [reserved] | _Currently unspecified_ |
| 0x2B | [reserved] | _Currently unspecified_ |
| 0x2C | [reserved] | _Currently unspecified_ |
| 0x2D | [reserved] | _Currently unspecified_ |
| 0x2E | [reserved] | _Currently unspecified_ |
| 0x2F | Matching Meta or Info | `Info_Matching_Meta` |
| **0x3* Negotiation and Governance** | | |
| 0x30 | Sender Disagrees or Nay | `Failure_Sender_Agreement` |
| 0x31 | Sender Agrees or Yea | `Success_Sender_Agreement` |
| 0x32 | Awaiting Ratification | `Info_Awaiting_Ratification` |
| 0x33 | Offer Sent or Voted | `Success_Offer_Sent`<br />`Success_Voted` |
| 0x34 | Quorum Not Reached | `Failure_Quorum_Not_Reached` |
| 0x35 | Receiver’s Ratification Requested | `Info_Receiver_Ratification_Requested` |
| 0x36 | Offer or Vote Limit Reached | `Failure_Offer_Limit_Reached`<br />`Failure_Vote_Limit_Reached` |
| 0x37 | [reserved] | _Currently unspecified_ |
| 0x38 | Already Voted | `Failure_Already_Voted` |
| 0x39 | [reserved] | _Currently unspecified_ |
| 0x3A | [reserved] | _Currently unspecified_ |
| 0x3B | [reserved] | _Currently unspecified_ |
| 0x3C | [reserved] | _Currently unspecified_ |
| 0x3D | [reserved] | _Currently unspecified_ |
| 0x3E | [reserved] | _Currently unspecified_ |
| 0x3F | Negotiation Rules or Participation Info | `Info_Negotiation_Rules` |
| **0x4* Availability and Time** | | |
| 0x40 | Unavailable | `Failure_Unavailable` |
| 0x41 | Available | `Success_Available` |
| 0x42 | Paused | `Info_Paused` |
| 0x43 | Queued | `Info_Queued` |
| 0x44 | Not Available Yet | `Failure_Not_Available_Yet` |
| 0x45 | Awaiting Your Availability | `Info_Awaiting_Own_Availability` |
| 0x46 | Expired | `Failure_Expired` |
| 0x47 | [reserved] | _Currently unspecified_ |
| 0x48 | Already Done | `Failure_Already_Done` |
| 0x49 | [reserved] | _Currently unspecified_ |
| 0x4A | [reserved] | _Currently unspecified_ |
| 0x4B | [reserved] | _Currently unspecified_ |
| 0x4C | [reserved] | _Currently unspecified_ |
| 0x4D | [reserved] | _Currently unspecified_ |
| 0x4E | [reserved] | _Currently unspecified_ |
| 0x4F | Availability Rules or Info (ex. time since or until) | `Info_Availability_Rules` |
| **0x5* Tokens, Funds and Finance** | | |
| 0x50 | Transfer Failed | `Failure_Transfer` |
| 0x51 | Transfer Successful | `Success_Transfer` |
| 0x52 | Awaiting Payment From Others | `Info_Awaiting_Parties_Payment` |
| 0x53 | Hold or Escrow | `Info_Hold`<br />`Info_Escrow` |
| 0x54 | Insufficient Funds | `Failure_Insufficient_Funds` |
| 0x55 | Funds Requested | `Success_Funds_Requested` |
| 0x56 | Transfer Volume Exceeded | `Failure_Transfer_Volumn_Exceeded` |
| 0x57 | [reserved] | _Currently unspecified_ |
| 0x58 | Funds Not Required | `Failure_Funds_Not_Required` |
| 0x59 | [reserved] | _Currently unspecified_ |
| 0x5A | [reserved] | _Currently unspecified_ |
| 0x5B | [reserved] | _Currently unspecified_ |
| 0x5C | [reserved] | _Currently unspecified_ |
| 0x5D | [reserved] | _Currently unspecified_ |
| 0x5E | [reserved] | _Currently unspecified_ |
| 0x5F | Token or Financial Information | `Info_Token_Information` |
| **0x6* Currently unspecified** | | |
| **0x7* Currently unspecified** | | |
| **0x8* Currently unspecified** | | |
| **0x9* Currently unspecified** | | |
| **0xA* Application-specific Codes** | | |
| 0xA0 | App-Specific Failure | `Failure_App_Generic` |
| 0xA1 | App-Specific Success | `Success_App_Generic` |
| 0xA2 | App-Specific Awaiting Others | `Info_App_Awaiting_Parties` |
| 0xA3 | App-Specific Acceptance | `Info_App_Acceptance` |
| 0xA4 | App-Specific Below Condition | `Info_App_Conditions` |
| 0xA5 | App-Specific Receiver Action Requested | `Info_App_Received_Action_Requested` |
| 0xA6 | App-Specific Expiry or Limit | `Failure_App_Expiry`<br />`Failure_App_Limit` |
| 0xA7 | [reserved] | _Currently unspecified_ |
| 0xA8 | App-Specific Inapplicable Condition | `Failure_App_Inapplicable_Condition` |
| 0xA9 | [reserved] | _Currently unspecified_ |
| 0xAA | [reserved] | _Currently unspecified_ |
| 0xAB | [reserved] | _Currently unspecified_ |
| 0xAC | [reserved] | _Currently unspecified_ |
| 0xAD | [reserved] | _Currently unspecified_ |
| 0xAE | [reserved] | _Currently unspecified_ |
| 0xAF | App-Specific Meta or Info | `Info_App_Generic` |
| **0xB* Currently unspecified** | | |
| **0xC* Currently unspecified** | | |
| **0xD* Currently unspecified** | | |
| **0xE* Encryption, Identity and Proofs** | | |
| 0xE0 | Decrypt Failure | `Failure_Decryption` |
| 0xE1 | Decrypt Success | `Success_Decryption` |
| 0xE2 | Awaiting Other Signatures or Keys | `Info_Awaiting_Parties_Signatures` |
| 0xE3 | Signed | `Success_Signed` |
| 0xE4 | Unsigned or Untrusted | `Info_Unsigned_Untrusted` |
| 0xE5 | Signature Required | `Info_Signature_Required` |
| 0xE6 | Known to be Compromised | `Info_Known_To_Be_Compromised` |
| 0xE7 | [reserved] | |
| 0xE8 | Already Signed or Not Encrypted | `Failure_Already_Signed` |
| 0xE9 | [reserved] | |
| 0xEA | [reserved] | |
| 0xEB | [reserved] | |
| 0xEC | [reserved] | |
| 0xED | [reserved] | |
| 0xEE | [reserved] | |
| 0xEF | Cryptography, ID, or Proof Metadata | `Info_Cryptography`<br />`Info_Metadata_Proof` |

Source: [EIP#1066 `EIP 1066: Status Codes`][eip-1066]

## Design Decisions

### 1. Namespaced Standards

Because each of the Token Standards will behave differently from others with regards to feature set integrations, we will implement commands in such a way that each standard can define its own extension to the standard command execution flow.

Commands will be grouped in **native modules** that are then exported such that each Token Standard can implement commands with its own feature set integration practises.

### 2. Standard Submodules

Due to the fact that token standards will be _namespaced_ and reside within there own folder inside the `src/standards/` folder, it is possible that subsequent token standards would be added to the package in the form of git submodules.

A new token standard that is to be implemented will typically be discussed and defined in a NIP.

### 3. Disposability and re-use

The delivered package will provide with several disposable and re-usable securities contracts that can be executed to manage securities on Symbol networks.

All types of Symbol objects MAY be used to implement a token standard. The `symbol-token-standards` library should bundle transactions inside _aggregate bonded transactions_ and MUST produce **[NIP2 compliant transaction URIs][doc-nip2]** to be executed _in secure environments_.

### 4. Network agnostic

Token standards that are implemented into `symbol-token-standards` MUST be network agnostic in that they MUST permit to issue and manage securities on any Symbol network.

The network variable is an important one when discussing the issuance of security tokens, as such a `NIP13.TokenSource` class is provided that is linked to security tokens upon their creation. The source of a token represents the original network of issuance of said token.

### 5. Deterministic accounts

The draft implementation of NIP 13 includes the usage of `symbol-hd-wallets` to derive deterministic **target accounts**, **operator accounts** and **partition accounts** that are later converted to multi-signature accounts.

More details will be described about the management of deterministic accounts that are generated within the scope of NIP 13.

## Implementation

This document defines a **Security Token Standard**.

Defined standards will leverage different feature sets of Symbol networks. More detailed implementation details will be described here.

In order to generalize and facilitate security token issuance and management with Symbol, we will publish **one software package** that integrates _all Token Standards_. The first token standard will be namespaced under `NIP13` namespace name.

Each of our token standards will be implementing features differently as to be more flexible and allow a broader scope of integrations or use case implementations.

The released software package will be developed with Typescript, using the [symbol-sdk@>=0.18.0][src-sdk] package to integrate latest Symbol features. The library MUST provide with interfaces and classes, which developers can leverage to manage issuance and redemptions of security tokens on Symbol.

As a proof of concept for this library, we MAY introduce either of a command line interface (CLI) or a basic web application to provide with out-of-the-box Security Token support for Symbol.

### Packaging Proposal

A deliverable package will be produced along with this NIP.

Following are the available package name suggestions, more may be added at a later point:

- [ ] ~~`symbol-token-standards`~~
- [ ] ~~`symbol-financial-instruments`~~
- [ ] ~~`symbol-financial-tools`~~
- [ ] ~~`symbol-derivatives`~~
- [ ] ~~`symbol-instruments`~~
- [x] `symbol-token-standards`

The decision making process for this package name selection will be made internally, more suggestions are welcome.

### Architecture Proposal

Each of our Security Token Standards will implement features with a pre-defined feature set of Symbol. This is important to note as this knowledge will influence the architecture of the release package. Following solution proposal can be applied:

```
- package.json
> src/
  > interfaces/
    - Standard.ts
    - Command.ts
    - Context.ts
  > standards/
    > NIP13/
      > commands/
        - CreateToken.ts
        - TransferOwnership.ts
        - AttachDocument.ts
    - NIP13.ts
  > models/
    - AllowanceResult.ts
    - etc.
```

### Implementation Proposal

#### Interfaces

- A `Standard` interface is defined that MUST contain following methods:

```javascript
  /**
   * @description The network configuration object.
   */
  readonly network: NetworkConfig

  /**
   * @description The token identifier
   */
  readonly identifier: TokenIdentifier

  /**
   * Synchronize the command execution with the network. This method shall
   * be used to fetch data required for execution.
   *
   * @async
   * @return {Promise<boolean>}
   */
  synchronize(): Promise<boolean>

  /**
   * Notify an account `account` about `notification`
   *
   * @param   {TokenIdentifier} tokenId
   * @param   {PublicAccount}   account
   * @param   {Notification}    notification
   * @param   {TransactionParameters} parameters
   * @return  {NotificationProof}
   **/
  notify(
    tokenId: TokenIdentifier,
    account: PublicAccount,
    notification: Notification,
    parameters: TransactionParameters,
  ): NotificationProof

  /**
   * Verifies **allowance** of `sender` to transfer `tokenId` security token.
   *
   * @param   {PublicAccount}         sender
   * @param   {TokenIdentifier} tokenId
   * @return  {AllowanceResult}
   **/
  canTransfer(
    sender: PublicAccount,
    tokenId: TokenIdentifier,
  ): AllowanceResult

  /**
   * Verifies **allowance** of `operator` to execute `command` with `tokenId` security token.
   *
   * @internal This method MUST use the `Command.canExecute()` method.
   * @param   {PublicAccount}         actor
   * @param   {TokenIdentifier}       tokenId
   * @param   {string}                command
   * @param   {Array<CommandOption>}  argv
   * @return  {AllowanceResult}
   **/
  canExecute(
    actor: PublicAccount,
    tokenId: TokenIdentifier,
    command: string,
    argv: CommandOption[]
  ): AllowanceResult

  /**
   * Execute `command` for Security Token with identifier `tokenId`. Arguments
   * the command execution can be passed in `argv`.
   *
   * @internal This method MUST use the `Command.execute()` method.
   * @param   {PublicAccount}         actor
   * @param   {TokenIdentifier}       tokenId
   * @param   {string}                command
   * @param   {TransactionParameters} parameters
   * @param   {Array<CommandOption>}  argv
   * @return  {TransactionURI}
   **/
  execute(
    actor: PublicAccount,
    tokenId: TokenIdentifier,
    command: string,
    parameters: TransactionParameters,
    argv: CommandOption[],
  ): TransactionURI

  /**
   * Gets an execution context
   *
   * @param   {PublicAccount}   actor
   * @param   {TransactionParameters} parameters
   * @param   {CommandOption[]} argv
   * @return  {Context}
   **/
  getContext(
    actor: PublicAccount,
    parameters: TransactionParameters,
    argv?: CommandOption[],
  ): Context

  /**
   * Gets a command instance around `context` and `tokenId`.
   *
   * @param {TokenIdentifier} tokenId 
   * @param {string}          command 
   * @param {Context}         context 
   * @return {Command}
   */
  getCommand(
    tokenId: TokenIdentifier,
    command: string,
    context: Context,
  ): Command
```

Classes implementing the `Standard` interface MUST make use of the `symbol-sdk` package to leverage Catapult features.

- A `Command` interface is defined that MUST contain following methods:

```javascript
  /**
   * @description The command name
   */
  readonly name: string

  /**
   * @description The command execution context
   */
  readonly context: Context

  /**
   * @description The command on-chain descriptor
   */
  readonly descriptor: string

  /**
   * Verifies **allowance** of `actor` to execute command.  Arguments to
   * the command execution can be passed in `argv`.
   *
   * @param   {PublicAccount}                actor
   * @param   {Array<CommandOption>}   argv
   * @return  {AllowanceResult}
   **/
  canExecute(
    actor: PublicAccount,
    argv: CommandOption[] | undefined,
  ): AllowanceResult

  /**
   * Execute the command with `actor` operator account. Arguments to
   * the command execution can be passed in `argv`.
   *
   * @param   {PublicAccount}           actor
   * @param   {Array<CommandOption>}    argv
   * @return  {TransactionURI}
   **/
  execute(
    actor: PublicAccount,
    argv: CommandOption[] | undefined,
  ): TransactionURI
```

Classes implementing the `Command` interface MUST make use of the `symbol-sdk` package to leverage Catapult features.

### Requirements Compliancy

Following the [list of requirements](#requirements), this section will define implementation options that MUST be available in described Token Standards.

- [x] MUST have a standard interface to query feasibility of a transfer and return a reason for failures.

- `canTransfer()`
- `canExecute()`

- [x] MUST be able to perform forced transfer for legal action or fund recovery.

- `execute(... new ForcedTransfer(), [Option.create('sender', '...'), Option.create('recipient', '...')])`

- [x] MUST define standard notifications for issuance and redemption processes.

- `canExecute(... new CreateToken(), [Option.create('tokenId', '...')])`

- [x] MUST be able to attach metadata to a **subset of a token holder's balance**.

- `execute(... new ModifyMetadata(), [Option.create('data', '...')])`

- [x] MUST be able to modify metadata at time of transfer based on off-chain data, on-chain data and the parameters of the transfer.

- `execute(... new ModifyMetadata(), [Option.create('data', '...')])`

- [x] MUST support querying and subscribing to updates on any relevant documentation for the security.

- `notify()`

- [x] MAY require signed data to be passed into a transfer transaction in order to validate it on-chain.

- `execute(... new TransferOwnershipWithData(), [Option.create('data', '...')])`

- [x] SHOULD NOT restrict the range of asset classes across jurisdictions which can be represented.

### Ongoing Work

| Story | Assigned | Progress |
| --- | --- | --- |
| Describe NIP13 and draft NIP | @evias | ![Progress](https://progress-bar.dev/100/) |
| Define Implementation details | @evias | ![Progress](https://progress-bar.dev/100/) |
| Start NIP13 implementation | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement base library layer | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement create/transfer token commands | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement lock/unlock token command | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement force transfer token command | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement modify metadata/restrictions token commands | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement delegate issuer power token command | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement attach document token command | @evias | ![Progress](https://progress-bar.dev/100/) |

## Backwards compatibility

This standard is backwards compatible with Symbol Mosaics as it relies solely on Symbol Mosaic and Accounts features.

## References

- [ERC#1400 `Security Token Standard`][erc-1400]
- [NFT Library `nem2-nonfungible-asset`][src-nft]
- [Symbol Typescript SDK][src-sdk]
- [Symbol][symbol] protocol
- [Symbol Developer Center][symbol-dev-center]

[symbol-dev-center]:https://nemtech.github.io
[symbol]:https://github.com/nemtech/catapult-server
[src-nft]:https://github.com/nemfoundation/nem2-nonfungible-asset
[src-nip13]:https://github.com/nemfoundation/symbol-token-standards
[src-sdk]:https://github.com/nemtech/symbol-sdk-typescript-javascript
[doc-nip2]:https://github.com/nemtech/NIP/blob/master/NIPs/nip-0002.md
[guide-create-mosaic]:https://nemtech.github.io/guides/mosaic/creating-a-mosaic.html
[erc-1400]:https://github.com/ethereum/EIPs/issues/1411
[eip-1066]:https://eips.ethereum.org/EIPS/eip-1066

## History

| **Date**     | **Version**    |
| ------------ | -------------- |
| July 29 2019 | Initial Draft  |
| March 11 2019 | Revised NST-1 |
| March 25 2020 | Revised NIP13 |
| May 04 2020 | Updated NIP13   |
| May 11 2020 | Updated NIP13   |
