# NIP 13 - Security Token Standard

```
    NIP: 13
    Layer: Library
    Title: Security Token Standard
    Author: Gregory Saive <greg@nem.foundation>
    Discussions-To: https://github.com/nemtech/NIP/issues/42
    Comments-URI: https://github.com/nemtech/NIP/issues/42
    Status: Draft
    Type: Standards Track
    Created: 2019-07-29
    License: Apache-2.0
```

## Table of contents

- [Introduction](#introduction)
- [Motivation](#motivation)
- [Rationale](#rationale)
  * [Partially Fungible Tokens](#partially-fungible-tokens)
- [Specification](#specification)
  * [Requirements](#requirements)
  * [Terminology](#terminology)
  * [Features Description](#features-description)
  * [Deterministic Accounts](#deterministic-accounts)
  * [Target Mosaic](#target-mosaic)
  * [Token Commands](#token-commands)
  * [Token Restrictions](#token-restrictions)
  * [Token Metadata](#token-metadata)
  * [Reason Codes](#reason-codes)
- [Design Decisions](#design-decisions)
  * [1. Namespaced Standards](#1--namespaced-standards)
  * [2. Standard Submodules](#2--standard-submodules)
  * [3. Disposability and re-use](#3--disposability-and-re-use)
  * [4. Network agnostic](#4--network-agnostic)
  * [5. Deterministic accounts](5--deterministic-accounts)
  * [6. Reason Codes](6--reason-codes)
- [Implementation](#implementation)
  * [Packaging Proposal](#packaging-proposal)
  * [Architecture Proposal](#architecture-proposal)
  * [Implementation Proposal](#implementation-proposal)
    + [Interfaces](#interfaces)
    + [Symbol Transactions](#symbol-transactions)
  * [Example Library Usage](#example-library-usage)
  * [Requirements Compliancy](#requirements-compliancy)
  * [Ongoing Work](#ongoing-work)
- [Backwards compatibility](#backwards-compatibility)
- [References](#references)
- [History](#history)

## Introduction

This document aims to provide with a **standard** for _issuance_ and _management_ of **security tokens** on Symbol. This standard will be structured as such that _standard interfaces_ will be defined to facilitate _operations_ and _interrogations_ related to security tokens.

## Motivation 

Facilitate and accelerate the processes of _issuance_ and _management_ of security tokens on Symbol.

To issue and manage securities on Symbol, this standard will leverage several Symbol features. Implementation details will be described in a document jointly to this standard definition.

## Rationale

Security token transfers can fail for different reasons in contrast to utility tokens. As for utility tokens it generally requires only the sender to have a sufficient balance.

> ... [The conditions for failure] could be related to metadata of the securities being transferred (i.e. whether they are subject to a lock-up period), the identity of the sender and receiver of the securities (i.e. whether they have been through a KYC process, whether they are accredited or an affiliate of the issuer) or for reasons unrelated to the specific transfer but instead set at the token level (i.e. the token contract enforces a maximum number of investors or a cap on the percentage held by any single investor).

For tokens representing securities, this standard introduces a function `canTransfer` which provides a general purpose path to achieve this when _the reasons for failure of a transfer are more complex_; _and/or a function of the whole transfer_ (i.e. includes any data sent with the transfer and the receiver of the securities).

Quoted: [ERC#1400 `Security Token Standard`][erc-1400]

### Partially Fungible Tokens

Security tokens can be used to represent many types of assets which need to have _differentiating data_ attached to them and/or signed.

This additional metadata - when added at a token level - implicitely renders these securities _non-fungible_, but in practice said data will be applied to a _subset of the security_ rather than an individual security.

With this standard, we introduce the ability to **partition** a token holder's balance intro partitions, _each with separate metadata_. 

> A token holder's balance may be split in two: those tokens issued during the primary issuance, and those received through secondary trading.

> Security token contracts can reference this metadata in order to apply additional logic to determine whether or not a transfer is valid, and determine the metadata that should be associated with the tokens once transferred into the receiver's balance.

Quoted: [ERC#1400 `Security Token Standard`][erc-1400]

## Specification

### Requirements

The security token standards to be described in this document will be based on features available with [Symbol][symbol] networks. Additionally, for each standard, we will define requirements that will apply to the underlying asset class.

> In aggregate provides a suite of standard interfaces for issuing / redeeming security tokens, managing their ownership and transfer restrictions and providing transparency to token holders on how different subsets of their token balance behave with respect to transfer restrictions, rights and obligations.In aggregate provides a suite of standard interfaces for issuing / redeeming security tokens, managing their ownership and transfer restrictions and providing transparency to token holders on how different subsets of their token balance behave with respect to transfer restrictions, rights and obligations.

- MUST have a standard interface to query feasibility of a transfer and return a reason for failures.
- MUST be able to perform forced transfer for legal action or fund recovery.
- MUST define standard notifications for issuance and redemption processes.
- MUST be able to attach metadata to a **subset of a token holder's balance**.
- MUST be able to modify metadata at time of transfer based on off-chain data, on-chain data and the parameters of the transfer.
- MUST support querying and subscribing to updates on any relevant documentation for the security.
- MAY require signed data to be passed into a transfer transaction in order to validate it on-chain.
- SHOULD NOT restrict the range of asset classes across jurisdictions which can be represented.

Source: [ERC#1400 `Security Token Standard`][erc-1400]

### Terminology

A **token** is represented by a multitude of features available with Symbol. This includes _mosaics_, _multi-signature accounts_, _namespaces_ and _metadata_.

A **token authority** is used to list tokens. One _token authority_ can list many _tokens_. There will be many token authorities (registrars) created with the sole purpose of listing tokens. In a future iteration, _token authorities_ may need to verify the creation of tokens they will be listing.

A **token operator** must have permissions to digitally _govern_ published tokens. There can be many operators for one token and the list of operators can change with the execution of some _token commands_.

A **token command** can be executed by _operators_ for their published _tokens_. A list of available token commands can be found [here](#token-commands).

A **token source** represents the original network of issuance of said token. Typically, the source for a security token represents the _exchange_ where the shares have been issued. In a digital environment it is probable that the source of tokens will require an annexed list of _verified sources_.

A **target account** is a deterministically created account that must be converted to a _multi-signature account_ where _cosignatories_ are **token operators**.

A **target mosaic** is a mosaic that is published to the network after the execution of the token command `CreateToken`. The **target mosaic** is owned by the **target account** and therefor _governed_ by the **token operators**.

A **token partition** represents _all or part of the token balance of a **token holder**_. One token partition can be _owned by one token owner_. The assignment of partitions can be tracked using a special transfer transaction signed by the _target account_.

For each **token partition**, there will be **one added multi-signature account** of which _token operator accounts_ are made cosignatories.

A **token holder** can be any account on Symbol networks which is not a **target account**, nor one of the listed **token operator**, nor one of the listed **token partitions**. Also, **token holders** may be subject to application-level verifications/constraints that authorize or deny the access to said security tokens.

### Features Description

Following features table will be used to define mandatory features of the published software package:

| Feature | Motivation | NIP13 Status |
| --- | --- | --- |
| Issuance | Issuance of security tokens is managed through `owner` | :white_check_mark: |
| Issuer Power Delegation | `Operators` can be allowed specific management tasks of the security tokens | :white_check_mark: |
| Transfer |  Security tokens can be transferred (change ownership) | :white_check_mark: |
| Batch Transfer | Security tokens can be transferred in batches (change ownership) | :white_check_mark: |
| Transfer with Metadata | Metadata can be added to transfers of security tokens | :white_check_mark: |
| Metadata management | Metadata can be managed for security tokens | :white_check_mark: |
| Transfer restrictions | Transfers of security tokens can be restricted (constraints) | :white_check_mark: |
| Freeze/Lock | Security token balances can be frozen/locked by `operators` | :white_check_mark: |
| Operator enforcement | `Operators` can be allowed tasks enforcements (such as transfers) | :white_check_mark: |
| Force Transfer | Transfers of security tokens can be **enforced**. | :white_check_mark: |
| Error signaling | Error signaling is described for each Standard | :white_check_mark: |
| Document management | Documents can be attached to security tokens [ownerships] | :white_check_mark: |

### Deterministic Accounts

This standard assumes the usage of the [`symbol-hd-wallets`][src-hd] package for keys derivation.

A **token authority** serves the purpose of _listing tokens_. It can be used for a token registrar (e.g. An exchange) to _verify a token listings before they are listed_. Each _token authority_ shall be created with a separate 24-words BIP39 mnemonic pass phrase.

A **target account** is a deterministic account that is generated and then converted to multi-signature accounts as such that it is _governed by token operators_. After conversion, the private key of said deterministic account **cannot be used for signatures creation or transactions execution**. Each _target account_ shall be created with a separate 24-words BIP39 mnemonic pass phrase.

The derivation paths used to generate said deterministic accounts are as follows:

- **Token Authority**: **m/44'/4343'/1313'/1313'/1313'**
- **Target Account**: **m/44'/4343'/1313'/0'/0'**
- **Token Holder Partitions**: **m/44'/4343'/1313'/0'/{PARTITION_ID}'**

:warning: More details to be added about the generation of a `PARTITION_ID`. The current solution uses only 3 bytes of data to generate the partition id. This may change over the next iterations.

### Target Mosaic

With the creation of a security token follows the creation of a **target mosaic** on Symbol distributed ledger network(s).

NIP13 compliant mosaics SHOULD use their **token identifier** as a **nonce** when creating the mosaic. This feature is part of the `CreateToken` token command.

Also, NIP13 compliant mosaics MUST be configured to be **restrictable** and **non-transferrable** on the Symbol network of issuance. This feature is part of the `CreateToken` token command.

Additional restrictions and metadata MUST be attached as described in the following sections:

- [Token Restrictions](#token-restrictions)
- [Token Metadata](#token-metadata)

### Token Commands

Token Standards introduce the term of **commands** that are executed for specific tokens. For instance, the transfer of token happens by _executing the command TransferOwnership_ for said token.

This concept of _commands_ will be available for all Token Standards. As such we will define a list of commands that will also be technically defined in the implementation details.

| Token Command | Rationale |
| --- | --- |
| **CreateToken** | Create a security token (non-reversible) |
| **CreatePartition** | Create a partition that will own a (portion of a) token holder balance | 
| **TransferOwnership** | Transfer a token to a new owner (Also used for issuance to single recipient) |
| **TransferOwnershipWithData** | Transfer a token to a new owner, adding signed data as a message |
| **BatchTransferOwnership** | Batch Transfer tokens to new owners |
| **BatchTransferOwnershipWithData** | Batch Transfer tokens to new owners, adding signed data as a message |
| **ForcedTransfer** | Force the transfer of a token to a new owner, with an operator account |
| **LockBalance** | Freeze / Lock a token balance (full or part of partition) |
| **UnlockBalance** | Unfreeze / Unlock a token balance (full or part of partition) |
| **ModifyRestriction** | Send modifications to account/mosaic restrictions |
| **ModifyMetadata** | Send modifications to account/mosaic metadata |
| **DelegateIssuerPower** | Delegate issuance authorizations to (new) operator(s) account(s) |
| **RevokeIssuerPower** | Revoke issuance authorizations of operator(s) account(s) |
| **AttachDocument** | Attach documents to a token instance |

### Token Restrictions

> **Token restrictions** MUST leverage [_Symbol mosaic restrictions features_](https://nemtech.github.io/concepts/mosaic-restriction.html).

1. A **target account** MUST be configured with following **account mosaic restrictions**:

- Add account mosaic restriction with flag `AllowMosaic` for said security token mosaic id.
- Add account mosaic restriction with flag `AllowMosaic` for the network currency mosaic id.

2. A **target mosaic** MUST be configured with following **mosaic global restriction**:

- Add mosaic global restriction of type `LE` (less or equal) with value `2` and key `User_Role`.
  * Proposed possible values includes: [1 = Target, 2 = Holder, 3 = Guest, 4 = Locked].

3. A **target mosaic** MUST be configured with following **mosaic address restrictions**:

- Add mosaic address restriction with value `1` (1 = Target) for _target account_.
- Add mosaic address restriction with value `2` (2 = Holder) for _each token partition_ - if any available.

4. A **token partition** MUST be configured with following **account mosaic restrictions**:

- Add account mosaic restriction with flag `AllowMosaic` for said security token mosaic id.
- Add account mosaic restriction with flag `AllowMosaic` for the network currency mosaic id.

### Token Metadata

> **Token metadata** MUST leverage [_Symbol metadata features_](https://nemtech.github.io/concepts/metadata.html).

1. A **target account** MUST be configured with the following **account metadata**:

- Add account metadata with key `NIP13` and value being the _token identifier_.

2. A **target mosaic** MUST be configured with the following **mosaic metadata**:

- Add mosaic metadata with key `NIP13` and value being the _token identifier_.
- Add mosaic metadata with key `NAME` and value being the _name of the financial instrument_.

3. (Optional) A **target mosaic** SHOULD be configured with the following **mosaic metadata**:

- Add mosaic metadata with key `MIC` and value being the _Market Identifier Code of the financial instrument_.
- Add mosaic metadata with key `ISIN` and value being the _International Securities Identification Number (ISIN) of the financial instrument_.
- Add mosaic metadata with key `ISO_10962` and value being the _classification of the financial instrument as described in ISO_10962_.

4. A **token partition** MUST be configured with the following **account metadata**:

- Add mosaic metadata with key `NAME` and value being the _name of the token partition_.

### Reason Codes

In an attempt to make the token holder experience better, the provided `canTransfer` function MUST return a _reason byte code_ on success or failure based on the NIP-13 application-specific status codes specified in [Annex 1: Reason Codes][annex-1].

An implementation can also return arbitrary data as a `uint8_t` to provide additional information not captured by the reason code.

> Codes break nicely into a 16x16 matrix, represented as a 2-digit hex number. The high nibble represents the code’s kind or “category”, and the low nibble contains the state or “reason”. We present them below as separate tables per range for explanatory and layout reasons.

Codes are defined in following categories:

- **`0x0*` Generic Failure Codes**
- **`0x1*` Permission and Control**
- **`0x2*` Find, Inequalities and Ranges**
- **`0x3*` Negotiation and Governance**
- **`0x4*` Availability and Time**
- **`0x5*` Tokens, Funds and Finance**
- **`0xA*` Application-specific Codes**
- **`0xE*` Encryption, Identity and Proofs**

## Design Decisions

### 1. Namespaced Standards

Because each of the Token Standards will behave differently from others with regards to feature set integrations, we will implement commands in such a way that each standard can define its own extension to the standard command execution flow.

Commands will be grouped in **native modules** that are then exported such that each Token Standard can implement commands with its own feature set integration practises.

### 2. Standard Submodules

Due to the fact that token standards will be _namespaced_ and reside within there own folder inside the `src/standards/` folder, it is possible that subsequent token standards would be added to the package in the form of git submodules.

A new token standard that is to be implemented will typically be discussed and defined in a NIP.

### 3. Disposability and re-use

The delivered package will provide with several disposable and re-usable securities contracts that can be executed to manage securities on Symbol networks.

All types of Symbol objects MAY be used to implement a token standard. The `symbol-token-standards` library should bundle transactions inside _aggregate bonded transactions_ and MUST produce **[NIP2 compliant transaction URIs][doc-nip2]** to be executed _in secure environments_.

### 4. Network agnostic

Token standards that are implemented into `symbol-token-standards` MUST be network agnostic in that they MUST permit to issue and manage securities on any Symbol network.

The network variable is an important one when discussing the issuance of security tokens, as such a `NIP13.TokenSource` class is provided that is linked to security tokens upon their creation. The source of a token represents the original network of issuance of said token.

### 5. Deterministic accounts

The draft implementation of NIP 13 includes the usage of `symbol-hd-wallets` to derive deterministic **target accounts**, **operator accounts** and **partition accounts** that are later converted to multi-signature accounts.

More details will be described about the management of deterministic accounts that are generated within the scope of NIP 13.

### 6. Reason Codes

We intentionally re-used reason codes from the [EIP-1066: Reason Codes][eip-1066] in order to provide with better interoperability caracteristics for our defined security token standards.

Credits go to the contributors of the Ethereum Improvement Proposal for the mapping of a 16x16 matrix describing categorized reason codes that the `canTransfer()` functionality MUST use for notifications and communication purposes.

## Implementation

This document defines a **Security Token Standard**.

Defined standards will leverage different feature sets of Symbol networks. More detailed implementation details will be described here.

In order to generalize and facilitate security token issuance and management with Symbol, we will publish **one software package** that integrates _all Token Standards_. The first token standard will be namespaced under `NIP13` namespace name.

Each of our token standards will be implementing features differently as to be more flexible and allow a broader scope of integrations or use case implementations.

The released software package will be developed with Typescript, using the [symbol-sdk@>=0.18.0][src-sdk] package to integrate latest Symbol features. The library MUST provide with interfaces and classes, which developers can leverage to manage issuance and redemptions of security tokens on Symbol.

As a proof of concept for this library, we MAY introduce either of a command line interface (CLI) or a basic web application to provide with out-of-the-box Security Token support for Symbol.

### Packaging Proposal

A deliverable package will be produced along with this NIP.

Following are the available package name suggestions, more may be added at a later point:

- [ ] ~~`symbol-token-standards`~~
- [ ] ~~`symbol-financial-instruments`~~
- [ ] ~~`symbol-financial-tools`~~
- [ ] ~~`symbol-derivatives`~~
- [ ] ~~`symbol-instruments`~~
- [x] `symbol-token-standards`

The decision making process for this package name selection will be made internally, more suggestions are welcome.

### Architecture Proposal

Each of our Security Token Standards will implement features with a pre-defined feature set of Symbol. This is important to note as this knowledge will influence the architecture of the release package. Following solution proposal can be applied:

```
- package.json
> src/
  > interfaces/
    - Standard.ts
    - Command.ts
    - Context.ts
  > standards/
    > NIP13/
      > commands/
        - CreateToken.ts
        - TransferOwnership.ts
        - AttachDocument.ts
    - NIP13.ts
  > models/
    - AllowanceResult.ts
    - etc.
```

### Implementation Proposal

#### Interfaces

- A `Standard` interface is defined that MUST contain following methods:

```javascript
/**
 * @interface Standard
 * @description Interface that describes security token standards.
 */
export interface Standard {
  /**
   * @description The network configuration object.
   */
  readonly network: NetworkConfig

  /**
   * @description The token identifier
   */
  readonly identifier: TokenIdentifier

  /**
   * Synchronize the command execution with the network. This method shall
   * be used to fetch data required for execution.
   *
   * @async
   * @return {Promise<boolean>}
   */
  synchronize(): Promise<boolean>

  /**
   * Notify an account `account` about `notification`
   *
   * @param   {TokenIdentifier} tokenId
   * @param   {PublicAccount}   account
   * @param   {Notification}    notification
   * @param   {TransactionParameters} parameters
   * @return  {NotificationProof}
   **/
  notify(
    tokenId: TokenIdentifier,
    account: PublicAccount,
    notification: Notification,
    parameters: TransactionParameters,
  ): NotificationProof

  /**
   * Verifies **allowance** of `sender` to transfer `tokenId` security token
   * to `recipient` with a number of shares attached of `amount`.
   *
   * @param   {TokenIdentifier} tokenId
   * @param   {PublicAccount}   sender
   * @param   {PublicAccount}   recipient
   * @param   {number}          amount
   * @return  {AllowanceResult}
   **/
  canTransfer(
    tokenId: TokenIdentifier,
    sender: PublicAccount,
    recipient: PublicAccount,
    amount: number,
  ): AllowanceResult

  /**
   * Verifies **allowance** of `operator` to execute `command` with `tokenId` security token.
   *
   * @internal This method MUST use the `Command.canExecute()` method.
   * @param   {PublicAccount}         actor
   * @param   {TokenIdentifier}       tokenId
   * @param   {string}                command
   * @param   {Array<CommandOption>}  argv
   * @return  {AllowanceResult}
   **/
  canExecute(
    actor: PublicAccount,
    tokenId: TokenIdentifier,
    command: string,
    argv: CommandOption[]
  ): AllowanceResult

  /**
   * Execute `command` for Security Token with identifier `tokenId`. Arguments
   * the command execution can be passed in `argv`.
   * 
   * This method MUST call the `synchronize()` method.
   *
   * @internal This method MUST use the `Command.execute()` method.
   * @param   {PublicAccount}         actor
   * @param   {TokenIdentifier}       tokenId
   * @param   {string}                command
   * @param   {TransactionParameters} parameters
   * @param   {Array<CommandOption>}  argv
   * @return  {Promise<TransactionURI>}
   **/
  execute(
    actor: PublicAccount,
    tokenId: TokenIdentifier,
    command: string,
    parameters: TransactionParameters,
    argv: CommandOption[],
  ): Promise<TransactionURI>

  /**
   * Execute `command` for Security Token with identifier `tokenId`. Arguments
   * the command execution can be passed in `argv`.
   * 
   * This method MUST NOT call the `synchronize()` method.
   *
   * @internal This method MUST use the `Command.execute()` method.
   * @param   {PublicAccount}         actor
   * @param   {TokenIdentifier}       tokenId
   * @param   {string}                command
   * @param   {TransactionParameters} parameters
   * @param   {Array<CommandOption>}  argv
   * @return  {TransactionURI}
   **/
  executeWithoutSync(
    actor: PublicAccount,
    tokenId: TokenIdentifier,
    command: string,
    parameters: TransactionParameters,
    argv: CommandOption[],
  ): TransactionURI
}
```

Classes implementing the `Standard` interface MUST make use of the `symbol-sdk` package to leverage Catapult features.

- A `Command` interface is defined that MUST contain following methods:

```javascript
/**
 * @interface Command
 * @description Interface that describes token commands.
 * @link https://github.com/nemtech/NIP/blob/master/NIPs/nip-0013.md#token-commands
 */
export interface Command {
  /**
   * @description The command name
   */
  readonly name: string

  /**
   * @description The command execution context
   */
  readonly context: Context

  /**
   * @description The command on-chain descriptor
   */
  readonly descriptor: string

  /**
   * Verifies **allowance** of `actor` to execute command.  Arguments to
   * the command execution can be passed in `argv`.
   *
   * @param   {PublicAccount}                actor
   * @param   {Array<CommandOption>}   argv
   * @return  {AllowanceResult}
   **/
  canExecute(
    actor: PublicAccount,
    argv: CommandOption[] | undefined,
  ): AllowanceResult

  /**
   * Execute the command with `actor` operator account. Arguments to
   * the command execution can be passed in `argv`.
   *
   * @param   {PublicAccount}           actor
   * @param   {Array<CommandOption>}    argv
   * @return  {TransactionURI}
   **/
  execute(
    actor: PublicAccount,
    argv: CommandOption[] | undefined,
  ): TransactionURI
}
```

Classes implementing the `Command` interface MUST make use of the `symbol-sdk` package to leverage Catapult features.

#### Symbol Transactions

This section SHOULD reflect the implementation proposal in [Source code for `symbol-token-standards` Library][src-nip13] and MUST list each token command's **descriptor**, **arguments** (input) and specify a **list of transactions** that will be wrapped inside an aggregate bonded transaction for the multiple parties to be able to take action on actions related to given security tokens.

#### Token command `CreateToken`

**Descriptor**: `NIP13(v1):create:6da3dbfc:8324B7C0A4F1F1E:no-name` with `6da3dbfc` that represents the _token identifier_, `8324B7C0A4F1F1E` that represents the created mosaic id and `no-name` that represents the security token name.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `name` | Name of the security token | `"NIP13 Example"` |
| `source` | Source network | `"Symbol Mainnet"` |
| `authority` | Token Authority account | `new PublicAccount(...)` |
| `operators` | Security Token Operators | `[new PublicAccount(...)]` |
| `supply` | Total number of outstanding shares | `123456` |
| `metadata` | Metadata associated at token level | `{'MIC': 'XNAS', ...}` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | MultisigAccountModificationTransaction | Converting **target** account to multisig with operators as cosignatories |
| 02 | AccountMetadataTransaction | Attaching `NIP13` token identifier |
| 03 | NamespaceRegistrationtTransaction | Registering namespace to be linked with target mosaic |
| 04 | MosaicDefinitionTransaction | Registering target mosaic |
| 05 | MosaicSupplyChangeTransaction | Adding total number of outstanding shares |
| 06 | MosaicAliasTransaction | Linking previously created namespace to target mosaic |
| 07 | MosaicMetadataTransaction | Attaching `NIP13` token identifier |
| 08 | MosaicMetadataTransaction | Attaching `NAME` security name |
| 09 | MosaicMetadataTransaction | Attaching `MIC` market identifier code |
| 10 | MosaicMetadataTransaction | Attaching `ISIN` if non-empty option provided |
| 11 | MosaicMetadataTransaction | Attaching `ISO_10962` if non-empty option provided |
| 12 | MosaicMetadataTransaction | Attaching `Website` if non-empty option provided |
| 13 | MosaicMetadataTransaction | Attaching `Sector` if non-empty option provided |
| 14 | MosaicMetadataTransaction | Attaching `Industry` if non-empty option provided |
| 15 | MosaicMetadataTransaction | Attaching custom metadata if non-empty option provided |
| 16 | AccountMosaicRestrictionTransaction | Adding target account allowance for target mosaic and network fee mosaic |
| 17 | MosaicGlobalRestriction | Adding token level restriction for `User_Role` <= 3 |
| 18 | MosaicAddressRestriction | Adding account level restriction value for `User_Role` with `1` (1 = Target) |
| 19 | TransferTransaction | Execution proof with NIP13 `CreateToken` descriptor |

:warning: `Transaction 03` represents the root namespace registration transaction. Any sub namespace registration transaction will be automatically added to this list.

:warning: `Transaction 09` will be added if a non-empty value is provided for the `mic` metadata field.

:warning: `Transaction 10` will be added if a non-empty value is provided for the `isin` metadata field.

:warning: `Transaction 11` will be added if a non-empty value is provided for the `iso10962` metadata field.

:warning: `Transaction 12` will be added if a non-empty value is provided for the `website` metadata field.

:warning: `Transaction 13` will be added if a non-empty value is provided for the `sector` metadata field.

:warning: `Transaction 14` will be added if a non-empty value is provided for the `industry` metadata field.

:warning: `Transaction 15` will be added if a non-empty value is provided for the custom metadata field.

#### Token command `CreatePartition`

**Descriptor**: `NIP13(v1):partition:6da3dbfc:default` with `6da3dbfc` said _token identifier_ and `default` the partition name.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `name` | Name of the token holder partition | `"NIP13 Example"` |
| `partition` | Token holder partition account | `new PublicAccount(...)` |
| `holder` | Actual token holder public account | `new PublicAccount(...)` |

:warning: The token holder _partition account_ and the _token holder account_ **MUST be public accounts** - a.k.a. must be known by the network. The account must have signed and announced at least one transaction before it is possible to execute this command.

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | MultisigAccountModificationTransaction | Converting **partition** account to multisig with operators and **token holder** as cosignatories |
| 02 | AccountMetadataTransaction | Attaching `NAME` partition name |
| 03 | AccountMosaicRestrictionTransaction | Adding partition account allowance for target mosaic and network fee mosaic |
| 04 | MosaicAddressRestriction | Adding account level restriction value for `User_Role` with `2` (2 = Holder) |
| 05 | TransferTransaction | Execution proof with NIP13 `CreatePartition` descriptor |

#### Token command `TransferOwnership`

**Descriptor**: `NIP13(v1):transfer:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `sender` | Sender token holder partition account (or use target account) | `new PublicAccount(...)` |
| `recipient` | Recipient token holder partition account | `new PublicAccount(...)` |
| `amount` | Number of shares to be transferred | `1` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

**1) Sending from _target account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 1.01 | TransferTransaction | Ownership transfer transaction |

**2) Sending from _partition account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 2.01 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 2.02 | TransferTransaction | Ownership transfer transaction |

#### Token command `TransferOwnershipWithData`

**Descriptor**: `NIP13(v1):data:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `sender` | Sender token holder partition account | `new PublicAccount(...)` |
| `recipient` | Recipient token holder partition account | `new PublicAccount(...)` |
| `amount` | Number of shares to be transferred | `1` |
| `data` | Plain text or encrypted data to attach | `Hello, world!` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

**1) Sending from _target account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 1.01 | TransferTransaction | Ownership transfer transaction |
| 1.02 | TransferTransaction | Execution proof with NIP13 `TransferOwnershipWithData` descriptor |
| 1.03 | TransferTransaction | Attaching data as a message |

**2) Sending from _partition account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 2.01 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 2.02 | TransferTransaction | Ownership transfer transaction |
| 2.02 | TransferTransaction | Execution proof with NIP13 `TransferOwnershipWithData` descriptor |
| 2.03 | TransferTransaction | Attaching data as a message |

#### Token command `BatchTransferOwnership`

**Descriptor**: `NIP13(v1):batch:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `sender` | Sender token holder partition account | `new PublicAccount(...)` |
| `recipients` | Recipient token holder partition accounts | `[new PublicAccount(...)]` |
| `amount` | Number of shares to be transferred | `1` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

**1) Sending from _target account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 1.01 | TransferTransaction | Execution proof with NIP13 `BatchTransferOwnership` descriptor |
| 1.02 | TransferTransaction | Ownership transfer transaction |

**2) Sending from _partition account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 2.01 | TransferTransaction | Execution proof with NIP13 `BatchTransferOwnership` descriptor |
| 2.02 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 2.03 | TransferTransaction | Ownership transfer transaction |

:warning: `Transaction 1.02` will be repeated for each valid partition account given in the `recipients` arguments.

:warning: `Transaction 2.03` will be repeated for each valid partition account given in the `recipients` arguments.

#### Token command `BatchTransferOwnershipWithData`

**Descriptor**: `NIP13(v1):batch:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `sender` | Sender token holder partition account | `new PublicAccount(...)` |
| `recipients` | Recipient token holder partition accounts | `[new PublicAccount(...)]` |
| `amount` | Number of shares to be transferred | `1` |
| `data` | Plain text or encrypted data to attach | `Hello, world!` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

**1) Sending from _target account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 1.01 | TransferTransaction | Execution proof with NIP13 `BatchTransferOwnership` descriptor |
| 1.02 | TransferTransaction | Ownership transfer transaction |
| 1.03 | TransferTransaction | Execution proof with NIP13 `TransferOwnershipWithData` descriptor |
| 1.04 | TransferTransaction | Attaching data as a message |

**2) Sending from _partition account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 2.01 | TransferTransaction | Execution proof with NIP13 `BatchTransferOwnership` descriptor |
| 2.02 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 2.03 | TransferTransaction | Ownership transfer transaction |
| 2.04 | TransferTransaction | Execution proof with NIP13 `TransferOwnershipWithData` descriptor |
| 2.05 | TransferTransaction | Attaching data as a message |

:warning: `Transaction 1.02`, `Transaction 1.03` and `Transaction 1.04` will be repeated for each valid partition account given in the `recipients` arguments.

:warning: `Transaction 2.03`, `Transaction 2.04` and `Transaction 2.05` will be repeated for each valid partition account given in the `recipients` arguments.

#### Token command `ForcedTransfer`

**Descriptor**: `NIP13(v1):forced-transfer:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `sender` | Sender token holder partition account | `new PublicAccount(...)` |
| `recipient` | Recipient token holder partition account | `new PublicAccount(...)` |
| `amount` | Number of shares to be transferred | `1` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

**1) Sending to a _target account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 1.01 | TransferTransaction | Execution proof with NIP13 `ForcedTransfer` descriptor |
| 1.02 | TransferTransaction | Ownership transfer transaction |

**2) Sending to a _partition account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 2.01 | TransferTransaction | Execution proof with NIP13 `ForcedTransfer` descriptor |
| 2.02 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 2.03 | TransferTransaction | Ownership transfer transaction |

#### Token command `LockBalance`

**Descriptor**: `NIP13(v1):lock:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `partition` | Token holder partition account (gets locked) | `new PublicAccount(...)` |
| `locker` | Token locker account (gets shares) | `new PublicAccount(...)` |
| `amount` | Number of shares to be locked | `1` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | TransferTransaction | Execution proof with NIP13 `LockBalance` descriptor |
| 02 | MultisigAccountModificationTransaction | Converting **locker** account to multisig with operators as cosignatories (token holder excluded) |
| 03 | AccountMetadataTransaction | Attaching `Is_Lock` flag to _locker account_ |
| 04 | AccountMosaicRestrictionTransaction | Adding locker account allowance for target mosaic and network fee mosaic |
| 05 | MosaicAddressRestriction | Adding account level restriction value for `User_Role` with `3` (3 = Locker) |
| 06 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 07 | TransferTransaction | Ownership transfer transaction |

#### Token command `UnlockBalance`

**Descriptor**: `NIP13(v1):unlock:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `partition` | Token holder partition account (gets unlocked) | `new PublicAccount(...)` |
| `locker` | Token locker account (sends back shares) | `new PublicAccount(...)` |
| `amount` | Number of shares to be unlocked | `1` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | TransferTransaction | Execution proof with NIP13 `UnlockBalance` descriptor |
| 02 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 03 | TransferTransaction | Ownership transfer transaction |

#### Token command `ModifyRestriction`

**Descriptor**: `NIP13(v1):restriction:6da3dbfc` with `6da3dbfc` said _token identifier_.

:warning: Executing this command may render the affected token incompliant with NIP13 requirements.

:warning: **Please, use this token command with care.**

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `restrictee` | Target account or partition account ("target of the restriction") | `new PublicAccount(...)` |
| `field` | Name of the restriction | `new PublicAccount(...)` |
| `value` | Minimumv value required for said restriction | `1` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

**1) With restrictee a _target account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 1.01 | TransferTransaction | Execution proof with NIP13 `ModifyRestriction` descriptor |
| 1.02 | MosaicGlobalRestrictionTransaction | Updating/adding token level restriction |

**2) With restrictee a _partition account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 2.01 | TransferTransaction | Execution proof with NIP13 `ModifyRestriction` descriptor |
| 2.02 | MosaicAddressRestrictionTransaction | Updating/adding token holder level restriction |

:warning: The execution of `Transaction 1.02` may render the affected token **incompliant with NIP13 requirements**. It is recommended to execute this token command _only if the action was verified by all token operators_.

#### Token command `ModifyMetadata`

**Descriptor**: `NIP13(v1):metadata:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `metadata` | Metadata associated at token level | `{'MIC': 'XNAS', ...}` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | TransferTransaction | Execution proof with NIP13 `ModifyMetadata` descriptor |
| 02 | MosaicMetadataTransaction | Updating `MIC` market identifier code |
| 03 | MosaicMetadataTransaction | Updating `ISIN` if non-empty option provided |
| 04 | MosaicMetadataTransaction | Updating `ISO_10962` if non-empty option provided |
| 05 | MosaicMetadataTransaction | Updating `Website` if non-empty option provided |
| 06 | MosaicMetadataTransaction | Updating `Sector` if non-empty option provided |
| 07 | MosaicMetadataTransaction | Updating `Industry` if non-empty option provided |
| 08 | MosaicMetadataTransaction | Updating custom metadata if non-empty option provided |

:warning: `Transaction 02` will be added if a non-empty value is provided for the `mic` metadata field.

:warning: `Transaction 03` will be added if a non-empty value is provided for the `isin` metadata field.

:warning: `Transaction 04` will be added if a non-empty value is provided for the `iso10962` metadata field.

:warning: `Transaction 05` will be added if a non-empty value is provided for the `website` metadata field.

:warning: `Transaction 06` will be added if a non-empty value is provided for the `sector` metadata field.

:warning: `Transaction 07` will be added if a non-empty value is provided for the `industry` metadata field.

:warning: `Transaction 08` will be added if a non-empty value is provided for the custom metadata field.

#### Token command `DelegateIssuerPower`

**Descriptor**: `NIP13(v1):add-operator:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `operator` | Operator account that will be added | `new PublicAccount(...)` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | TransferTransaction | Execution proof with NIP13 `DelegateIssuerPower` descriptor |
| 02 | MultisigAccountModificationTransaction | Adding **operator** account as a new cosignatory of the **target account** |
| 03 | MultisigAccountModificationTransaction | Adding **operator** account as a new cosignatory of any **partition account** |

:warning: `Transaction 03` will be repeated for each token holder partition.

#### Token command `RevokeIssuerPower`

**Descriptor**: `NIP13(v1):remove-operator:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `operator` | Operator account that will be removed | `new PublicAccount(...)` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | TransferTransaction | Execution proof with NIP13 `RevokeIssuerPower` descriptor |
| 02 | MultisigAccountModificationTransaction | Removing **operator** account of the **target account** cosignatories |
| 03 | MultisigAccountModificationTransaction | Removing **operator** account of any **partition account** cosignatories |

:warning: `Transaction 03` will be repeated for each token holder partition.

#### Token command `AttachDocument`

**Descriptor**: `NIP13(v1):document:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `filenode` | IPNS file name attributed to IPFS content | `"QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd"` |
| `filename` | The original file name that is being attached | `"Copy_of_ID.png"` |
| `recipient` | The recipient account (either of _target_ or _partition_ accounts) | `new PublicAccount(...)`

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | TransferTransaction | Execution proof with NIP13 `AttachDocument` descriptor |
| 02 | TransferTransaction | Attaching document hash to be signed by recipient account |

### Example Library Usage

The following example usage for the `symbol-token-standards` library is subject to change.

```javascript
import { AggregateTransaction, PublicAccount, SignedTransaction } from 'symbol-sdk'
import { MnemonicPassPhrase } from 'symbol-hd-wallets'
import { NIP13, NetworkConfig, TransactionParameters } from 'symbol-token-standards'
import { TransactionURI } from 'symbol-uri-scheme'

// :warning: The following settings are network specific and may need changes
const transactionParams = new TransactionParameters(
  Deadline.create(),
  750000, // maxFee
)

// :warning: You should create separate backups of
// authorities and security token pass phrases.
const authKeys = MnemonicPassPhrase.createRandom() // backup the resulting 24-words safely!
const tokenKeys = MnemonicPassPhrase.createRandom() // backup the resulting 24-words safely!

// :warning: It is recommended to create operator
// keys offline and using a separate device.
const operators = [
  new PublicAccount('PUBLIC_KEY_OPERATOR_1', 'ADDRESS_OPERATOR_1'),
  new PublicAccount('PUBLIC_KEY_OPERATOR_2', 'ADDRESS_OPERATOR_2'),
  // ...
]

// initialize NIP13 library
const network = new NetworkConfig(...)
const tokenAuthority = new NIP13.TokenAuthority(network, authKeys)
const securityToken = new NIP13.Token(network, tokenKeys)

// offline creation of the `CreateToken` security token contract
const metadata = new SecuritiesMetadata(
  'MIC',
  'ISIN',
  'ISO_10962',
  'Website',
  'Sector',
  'Industry',
  {
    'customKey1': 'metadata',
    // ...
  },
)
const tokenId = securityToken.create(
  'My Awesome Security Token', // security token name
  securityToken.getTarget().publicAccount, // actor
  tokenAuthority.getAuthority().publicAccount, // token authority
  operators,
  123456789, // supply
  metadata,
  transactionParams,
)

// get the transaction URI for `CreateToken` execution
const resultURI: TransactionURI = securityToken.result

// :warning: It is recommended to sign the security token using
// a hardware wallet rather than any type of software generated
// wallets.
const transaction: AggregateTransaction = resultURI.toTransaction()
const signedTransaction: SignedTransaction = securityToken.getTarget().sign(transaction, 'generationHash')

// `signedTransaction` can now be broadcast to the Symbol network of choice.

// It is important to denote that given the **aggregate** nature of security
// token contracts, multiple parties MAY be involved in the transaction and
// it is therefor required to issue a HashLockTransaction before announcing
// the aggregate bonded transaction that represents the contract.
```

### Requirements Compliancy

Following the [list of requirements](#requirements), this section will define implementation options that MUST be available in described Token Standards.

- [x] MUST have a standard interface to query feasibility of a transfer and return a reason for failures.

- `canTransfer()`
- `canExecute()`

- [x] MUST be able to perform forced transfer for legal action or fund recovery.

- `execute(... new ForcedTransfer(), [Option.create('sender', '...'), Option.create('recipient', '...')])`

- [x] MUST define standard notifications for issuance and redemption processes.

- `canExecute(... new CreateToken(), [Option.create('tokenId', '...')])`

- [x] MUST be able to attach metadata to a **subset of a token holder's balance**.

- `execute(... new ModifyMetadata(), [Option.create('data', '...')])`

- [x] MUST be able to modify metadata at time of transfer based on off-chain data, on-chain data and the parameters of the transfer.

- `execute(... new ModifyMetadata(), [Option.create('data', '...')])`

- [x] MUST support querying and subscribing to updates on any relevant documentation for the security.

- `notify()`

- [x] MAY require signed data to be passed into a transfer transaction in order to validate it on-chain.

- `execute(... new TransferOwnershipWithData(), [Option.create('data', '...')])`

- [x] SHOULD NOT restrict the range of asset classes across jurisdictions which can be represented.

### Ongoing Work

| Story | Assigned | Progress |
| --- | --- | --- |
| Describe NIP13 and draft NIP | @evias | ![Progress](https://progress-bar.dev/100/) |
| Define Implementation details | @evias | ![Progress](https://progress-bar.dev/100/) |
| Start NIP13 implementation | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement base library layer | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement create/transfer token commands | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement lock/unlock token command | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement force transfer token command | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement modify metadata/restrictions token commands | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement delegate issuer power token command | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement attach document token command | @evias | ![Progress](https://progress-bar.dev/100/) |

## Backwards compatibility

This standard is backwards compatible with Symbol Mosaics as it relies solely on Symbol Mosaic and Accounts features.

## References

- [ERC#1400 `Security Token Standard`][erc-1400]
- [NFT Library `nem2-nonfungible-asset`][src-nft]
- [Symbol Typescript SDK][src-sdk]
- [Symbol][symbol] protocol
- [Symbol Developer Center][symbol-dev-center]

## Annexes

Annexes to this NIP are listed below:

- [Annex 1: Reason Codes][annex-1]
- [Source code for `symbol-token-standards` Library][src-nip13]

## History

| **Date**     | **Version**    |
| ------------ | -------------- |
| July 29 2019 | Initial Draft  |
| March 11 2019 | Revised NST-1 |
| March 25 2020 | Revised NIP13 |
| May 04 2020 | Updated NIP13   |
| May 11 2020 | Updated NIP13   |


[annex-1]:nip-0013/reason-codes.md
[symbol-dev-center]:https://nemtech.github.io
[symbol]:https://github.com/nemtech/catapult-server
[src-nft]:https://github.com/nemfoundation/nem2-nonfungible-asset
[src-nip13]:https://github.com/nemfoundation/symbol-token-standards
[src-sdk]:https://github.com/nemtech/symbol-sdk-typescript-javascript
[src-hd]:https://github.com/nemfoundation/symbol-hd-wallets
[doc-nip2]:https://github.com/nemtech/NIP/blob/master/NIPs/nip-0002.md
[guide-create-mosaic]:https://nemtech.github.io/guides/mosaic/creating-a-mosaic.html
[erc-1400]:https://github.com/ethereum/EIPs/issues/1411
[eip-1066]:https://eips.ethereum.org/EIPS/eip-1066
