# NIP 14 - Release Management for Symbol Packages

```
    NIP: 14
    Title: Release Management for Symbol Packages
    Author: Fernando Boucquez <fernando.boucquez@nemstudios.io>
    Comments-URI: https://github.com/nemtech/NIP/issues/44
    Status: Draft
    Type: Process
    Created: 2020-03-25
    License: Apache 2.0
    License-Code: Apache 2.0
```

## Introduction

This document describes the standard release cycle for all the packages hosted under the nemtech org.

## Specification

### Versioning

All projects must adhere to the [Semantic Versioning 2.0.0](https://semver.org/).

> Given a version number MAJOR.MINOR.PATCH, increment the:
MAJOR version when you make incompatible API changes,
MINOR version when you add functionality in a backwards compatible manner, and
PATCH version when you make backwards compatible bug fixes.
 
Versions between projects should remain independent. 
 
### Changelog
 
New releases must include a CHANGELOG based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
 
If a project has dependencies with other Symbol packages, the CHANGELOG must attach the following table per new version describing the dependencies:

**Milestone**: catapult-server milestone name (version number)
 
 | Library     |Version  | Package         |
 | ------------|---------|---------------- |
 |Library name | v0.17.3 | Link to package |

### Tooling

The majority of our projects use TravisCI as the CI automation tool, but you can use Jenkins or any other tool that suits the process if you are more comfortable with it.

## Sanity Check

Every time there is a new commit, the build scripts should:

* build the package
* run the unit tests
* pass the linter

GitHub should prevent merging the PRs that do not pass the requirements mentioned above.

## Alpha deployments

Every time there is a new push to main branch, the build scripts should generate and deploy a new testable version like  ``0.17.1-ALPHA-20200220T120318``.

Note that there is a timestamp suffix since package managers may not allow redeployments of the same version. If the package manager allows reployments of SNAPSHOT, using a timestamp is not necessary in this case.

The timestamp is automatically generated by the CI automation tool.There should not be any manual process like writing down the version 0.17.1-ALPHA-1 or 0.17.1-ALPHA-2.

A client can use an alpha dependency like "symbol-sdk": "0.17.1-ALPHA-20200220T120318".

### Exception: Code generators

Code generators (catbuffer-generators, symbol-openapi-generator) differ from the above in one aspect: alpha deployments are not done automatically from main branch. Instead, they are triggered from language specific release branches due to the fact that code generators build multiple independent deployment artifacts e.g. one for each language, each of which can be released independently.

## Full release

Every time we want to release, we create a PR from main to the release branch.
The PR will include the CHANGELOG update explaining the new features.

Once PR is approved, the CI automation tool will pick it up, build and then it will perform a release. 

The release script should:

* git tag the to-be-released version (e.g: v0.17.4)
* publish the current version into the package manager (e.g. npm, docker hub - 0.17.4)
* upgrade the package version (e.g: 0.17.5 using npm version patch)
* add & commit changes
* push commits into main branch (eg: package.json will have the new 0.17.5)
* push the tag (v0.17.4)

## Motivation

**Standarized release process**

How the release process is done is committed and documented in the travis file and scripts. Itâ€™s not done in a dev machine. Anybody can understand it and perform a release.

**Tighter feedback loop**

Users need to wait for a proper release before start using a new feature in our packages. Although the process is quite dynamic, it could take a few days before getting a release that aggregates many improvements together.

The proposal is to add the right versioning and token in the CI automation tool scripts so every time a PR is merged to main, a pipeline pushes a new alpha/snapshot to the package manager. If a user is waiting for a fix, that fix will be included in the package manager automatically after the new main branch is merged.

**Faster releases**

Using the snapshot, the Symbol team can do extra checks and feedback before doing a release,by smoke testing the snapshot artifact in other projects like the CLI, wallet or explorer. Even the examples in the docs can be upgraded before the package is released.

## Implementation

The Symbol SDK for Typescript follows the release cycle defined in this document using TravisCI.

Note: The implementation depends on the framework and programming language, the TS implementation is just an example. 

* ``travis.yml``: https://github.com/nemtech/symbol-sdk-typescript-javascript/blob/main/.travis.yml

* Releases script: https://github.com/nemtech/symbol-sdk-typescript-javascript/blob/main/travis/release.sh

* Alpha releases script: https://github.com/nemtech/symbol-sdk-typescript-javascript/blob/main/travis/uploadArchives.sh

### Travis settings

Travis will hold the necessary tokens and encryption keys to perform a release using env variables. The most common ones are:

* ``NPM_TOKEN``: The token used to push npm artifacts into a npm repository https://docs.npmjs.com/creating-and-viewing-authentication-tokens 

* ``GITHUB_TOKEN``: The token used to push the version increases, tags and documentation (GitHub Pages) into GitHub. The user needs to be able to publish from the release branch to main once the version is updated.
 https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line
* ``RELEASE_BRANCH``: The name of the release branch. Example: ``release``.
* (Optional): ``signingKeyId``, ``signingPassword``, ``signingSecretKeyRingFile`` and the Travis encrypted private key. The values necessary for sign packages. https://medium.com/@nmauti/sign-and-publish-on-maven-central-a-project-with-the-new-maven-publish-gradle-plugin-22a72a4bfd4b

We would need other tokens for Docker, Sonar, or PIP deployments to be defined. 

The generated tokens should be from users with enough permissions (for example, a user that can push to GitHub Pages branch or npm).

##  Projects following the NIP

* [x] symbol-sdk-typescript-javascript
* [x] symbol-sdk-java
* [x] symbol-cli
* [x] symbol-openapi
* [x] symbol-openapi-generator
* [ ] catbuffer-generators
* [ ] symbol-docs
* [ ] catapult-rest
* [ ] catapult-server

##  Backwards compatibility

No backward incompatibility issues. The uploaded artifacts are the same, just deployed from Travis instead of a developer machine.

## Contributors

Special thanks to [@dgarcia360](https://github.com/dgarcia360)and [@rg911](https://github.com/rg911) for contributing actively to this NIP.

## History

| **Date**          | **Version**   |
| ----------------- | ------------- |
| March 25 2020     | Initial Draft |
