# NIP-0020 - Small file storage format

Note, this is only a proposal and it might change.

## Summary

```
    NIP: 20
    Layer: Applications
    Title: Small file storage format
    Author: gimre <g.imre@protonmail.com>, Kristy-Leigh Minehan <kristy-leigh.minehan@nem.software>
    Comments-URI: https://github.com/nemtech/NIP/issues/58
    Status: Draft 
    Type: Informational
    Created: 2021-06-11
    License: MIT
```

## Introduction/Abstract

Motivation for this proposal is a tweet from Peersyst: https://twitter.com/peersyst/status/1402948911145304065

> Saving files decentralized allows you to pay only once and have immutable and unlimited access to them. This is a perfect environment for:
> Save backups (immutability, timestamp, availability) Closed lock with key
> Save files on-chain without having to use @ipfs

As I (gimre) have mentioned in public, I don't think using the main Symbol public blockchain for general storage purposes is a good idea. However, there are some uses that _might_ be wanted, such as: gists, markdown documents, markdeep documents.
Those can be easily be retrieved and rendered.

This proposal describes format for such small documents.

## Specification

For small files storage aggregate transaction with transfer are everything that is needed.
 * every aggregate transaction has network limit `[plugin:catapult.plugins.aggregate] maxTransactionsPerAggregate = 100`
 * every transfer transaction has network limit `[plugin:catapult.plugins.transfer] maxMessageSize = 1024`
 * transactions within aggregate are ordered, so all that is needed is concatenating their contents

This resuls in natural limit of 100kb per file. This is pretty sane limit for files that are basically formatted textfiles. At the moment of writing this, biggest cpp file in catapult server repository is ~65kb.

Recipient of the transfer transaction should be `<fill-final-address-later>`.

Every file should start with a header. The exact format of the header is a subject for discussion.
The header should be present only in first transfer.

1. `<marker>` initial marker similar to delegation message - `FE` `3938338A853E2B`
2. `<field_type> <value_length> <value>` - both `field_type` and `value_length` are 1 byte
3. `<field_type> <value_length> <value>`
4. ...
5. `<data>`

Fields should be sorted by field type, field type should not repeat (this might be relaxed in future).

Note that one byte limit, limits every value to at most 255 bytes

Standard field types:

* `01` - filename and/or title of the document
* `02` - (optional) file type (used for syntax highlighting) If file type is not present it should be deduced from extension. Note, render does not need to use this information at all.
* `03` - (optional) compression type, currently only `zlip` compression is supported
   * full marker for `zlib` compression: `03 04 7A 6C 69 62`
* `04` - (should be present, when `03` is present, can be skipped if `05` is present), size of decompressed file in bytes, encoded as little endian
* `05` - (optional) symmetric encrypion algorithm - used for 'private' gists, that can only be accessed with a password
   * currently unspecified
* `0A` - (optional) document version
* `0B` - (optional) previous document version (specified by hash of earlier transaction)
* `FF` - (compressed) data length in bytes, encoded as little endian - used as marker of beginning of data, so must always be present

Note: when creating a file compression should be applied before encryption and in reverse order when rendering the file.

## Design Decisions

Header could be smaller, but it's designed to be easy to parse.

## Implementation

## Alternatives

## References

## History

| **Date**      | **Version**   |
| ------------- | ------------- |
| Jun 11 2021    | Initial Draft |
